var Q=Object.defineProperty;var H=(e,o,t)=>o in e?Q(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t;var M=(e,o,t)=>H(e,typeof o!="symbol"?o+"":o,t);import{g as _,e as G}from"./assets/aiAnalyzer-BkmGpRcN.js";import{b as Y,r as V,a as W,g as j}from"./assets/migrationService-BOBvXKh-.js";import{c as Z}from"./assets/frecencyCalculator-Bb0wlEmp.js";import{g as b}from"./assets/Readability-readerable-BjCyo2u9.js";import{getMetadataService as T}from"./assets/metadataService-DTk4NWNM.js";const v="aiFolderMigrationCompleted",X="aiFolderMigrationLog";async function J(){try{const e=await chrome.storage.local.get([v,"bookmarks"]);return e[v]?!1:(e.bookmarks||[]).some(n=>n.aiFolderPath&&n.aiFolderPath!=="/"&&n.aiFolderPath.trim()!==""&&(!n.folderPath||n.folderPath==="/"))}catch(e){return console.error("[Migration] Failed to check migration status:",e),!1}}async function ee(){try{return!!(await chrome.storage.local.get(v))[v]}catch(e){return console.error("[Migration] Failed to check migration completion:",e),!1}}async function E(){try{await chrome.storage.local.set({[v]:!0}),console.log("[Migration] Migration marked as completed")}catch(e){throw console.error("[Migration] Failed to mark migration as completed:",e),e}}async function te(e){try{await chrome.storage.local.set({[X]:e}),console.log("[Migration] Migration log saved:",e)}catch(o){console.error("[Migration] Failed to save migration log:",o)}}function oe(e){const o=[],t=e.split("/").filter(Boolean);for(let n=1;n<=t.length;n++)o.push("/"+t.slice(0,n).join("/"));return o}function re(e){return!e.aiFolderPath||e.aiFolderPath==="/"||e.aiFolderPath.trim()===""||e.folderPath&&e.folderPath!=="/"?e:{...e,folderPath:e.aiFolderPath,folderId:`folder-${e.aiFolderPath}`,aiFolderPath:void 0,aiFolderId:void 0,aiCategory:void 0,aiSubcategory:void 0,updateTime:Date.now()}}async function ae(){const e=Date.now(),o={migrated:0,skipped:0,errors:[],foldersCreated:0};console.log("[Migration] Starting AI folder migration...");try{if(await ee())return o.message="è¿ç§»å·²å®Œæˆï¼Œæ— éœ€é‡å¤æ‰§è¡Œ",o.skipped=-1,console.log("[Migration] Migration already completed, skipping"),o;const n=await chrome.storage.local.get(["bookmarks","folders"]),r=n.bookmarks||[],i=n.folders||[];if(r.length===0)return o.message="æ²¡æœ‰ä¹¦ç­¾éœ€è¦è¿ç§»",await E(),console.log("[Migration] No bookmarks to migrate"),o;const a=r.filter(c=>c.aiFolderPath&&c.aiFolderPath!=="/"&&c.aiFolderPath.trim()!==""&&(!c.folderPath||c.folderPath==="/"));if(a.length===0)return o.message="æ²¡æœ‰ AI åˆ†ç±»æ•°æ®éœ€è¦è¿ç§»",await E(),console.log("[Migration] No AI folder data to migrate"),o;console.log(`[Migration] Found ${a.length} bookmarks to migrate`);const u=new Set;a.forEach(c=>{c.aiFolderPath&&oe(c.aiFolderPath).forEach(k=>u.add(k))});const l=Array.from(u).sort();console.log(`[Migration] Need to create ${l.length} folders:`,l);const s=[],f=new Set(i.map(c=>c.id));for(const c of l){const m=`folder-${c}`;if(!f.has(m)){const k=c.split("/").filter(Boolean).pop()||"",B="/"+c.split("/").filter(Boolean).slice(0,-1).join("/"),w=B==="/"?void 0:`folder-${B}`,A={id:m,title:k,path:c,parentId:w,description:`ä»Ž AI åˆ†ç±»è¿ç§»: ${k}`,bookmarkCount:0,subfolderCount:0,createTime:Date.now(),updateTime:Date.now(),order:i.length+s.length};s.push(A),f.add(m),o.foldersCreated++,console.log(`[Migration] Created folder: ${c}`)}}const h=r.map(c=>{if(c.aiFolderPath&&c.aiFolderPath!=="/"&&c.aiFolderPath.trim()!==""&&(!c.folderPath||c.folderPath==="/"))try{const m=re(c);return o.migrated++,console.log(`[Migration] Migrated bookmark: "${c.title}" -> ${m.folderPath}`),m}catch(m){const k=`Failed to migrate bookmark "${c.title}": ${m.message}`;return o.errors.push(k),console.error(`[Migration] ${k}`),c}return o.skipped++,c}),d=new Map;h.forEach(c=>{if(c.folderPath&&c.folderPath!=="/"&&c.status==="active"){const m=`folder-${c.folderPath}`;d.set(m,(d.get(m)||0)+1)}}),s.forEach(c=>{c.bookmarkCount=d.get(c.id)||0});const g=[...i,...s];await chrome.storage.local.set({bookmarks:h,folders:g}),await E();const p=Date.now()-e,y={timestamp:Date.now(),migrated:o.migrated,skipped:o.skipped,foldersCreated:o.foldersCreated,errors:o.errors,duration:p};return await te(y),o.message=`è¿ç§»å®Œæˆï¼š${o.migrated} ä¸ªä¹¦ç­¾å·²è¿ç§»ï¼Œ${o.foldersCreated} ä¸ªæ–‡ä»¶å¤¹å·²åˆ›å»º`,console.log(`[Migration] Migration completed in ${p}ms:`,o),o}catch(t){const n=`Migration failed: ${t.message}`;return o.errors.push(n),o.message=n,console.error("[Migration]",n,t),o}}let z=!1;async function ne(){if(z){console.log("[BookmarkServiceInit] Already initialized");return}console.log("[BookmarkServiceInit] Starting initialization...");try{const e=Y();if(await e.needsMigration()){console.log("[BookmarkServiceInit] Migration needed, starting migration...");const r=await e.migrate(i=>{console.log(`[BookmarkServiceInit] Migration progress: ${i.current}/${i.total} - ${i.message}`)});r.success?(console.log("[BookmarkServiceInit] Migration completed successfully:",r),await e.cleanupOldData(),console.log("[BookmarkServiceInit] Old data cleaned up")):console.error("[BookmarkServiceInit] Migration failed:",r.errors)}const t=b();await t.initialize(),console.log("[BookmarkServiceInit] BookmarkService initialized, AnyMark root ID:",t.getAnyMarkRootId());const n=T();await n.initialize(),console.log("[BookmarkServiceInit] MetadataService initialized"),ie(t,n),z=!0,console.log("[BookmarkServiceInit] Initialization complete")}catch(e){throw console.error("[BookmarkServiceInit] Initialization failed:",e),e}}function ie(e,o){e.onBookmarkCreated(async t=>{console.log("[BookmarkServiceInit] External bookmark created:",t.id,t.title);try{await o.createDefaultMetadata(t.id,"browser"),F("BOOKMARK_CREATED",{chromeId:t.id})}catch(n){console.error("[BookmarkServiceInit] Failed to handle bookmark creation:",n)}}),e.onBookmarkRemoved(async t=>{console.log("[BookmarkServiceInit] External bookmark removed:",t);try{await o.deleteMetadata(t),F("BOOKMARK_REMOVED",{chromeId:t})}catch(n){console.error("[BookmarkServiceInit] Failed to handle bookmark removal:",n)}}),e.onBookmarkChanged(async(t,n)=>{console.log("[BookmarkServiceInit] External bookmark changed:",t,n),F("BOOKMARK_CHANGED",{chromeId:t,changeInfo:n})}),e.onBookmarkMoved(async(t,n)=>{console.log("[BookmarkServiceInit] External bookmark moved:",t,n),F("BOOKMARK_MOVED",{chromeId:t,moveInfo:n})}),console.log("[BookmarkServiceInit] External change listeners set up")}function F(e,o){chrome.runtime.sendMessage({type:"BOOKMARKS_UPDATED",reason:e,data:o}).catch(()=>{})}console.log("[Background] Service Worker initialized");console.log("[Background] Initializing Recent Tabs Service...");V.loadFromStorage().then(()=>{console.log("[Background] Recent Tabs Service initialized")}).catch(e=>{console.error("[Background] Failed to initialize Recent Tabs Service:",e)});async function ce(){try{console.log("[Background] Initializing new bookmark architecture..."),await ne(),console.log("[Background] New bookmark architecture initialized successfully")}catch(e){console.error("[Background] Failed to initialize new bookmark architecture:",e)}}ce();async function D(){try{if(await J()){console.log("[Background] AI folder migration needed, starting...");const o=await ae();console.log("[Background] Migration result:",o),o.migrated>0&&chrome.runtime.sendMessage({type:"BOOKMARKS_UPDATED",reason:"migration",migrated:o.migrated}).catch(()=>{})}else console.log("[Background] No AI folder migration needed")}catch(e){console.error("[Background] Migration failed:",e)}}D();async function se(){try{const e=W();await e.initialize();const o=await e.cleanup();o>0?console.log(`[Background] Cleaned up ${o} expired operation history records`):console.log("[Background] No expired operation history records to clean up")}catch(e){console.error("[Background] Failed to cleanup operation history:",e)}}se();async function le(){try{await j().initialize(),console.log("[Background] Chrome sync service initialized")}catch(e){console.error("[Background] Failed to initialize Chrome sync service:",e)}}le();const P="frecency-recalculate",ue=60*24;async function de(){try{await chrome.alarms.get(P)?console.log("[Background] Frecency alarm already exists"):(await chrome.alarms.create(P,{delayInMinutes:1,periodInMinutes:ue}),console.log("[Background] Frecency alarm created: every 24 hours"))}catch(e){console.error("[Background] Failed to create frecency alarm:",e)}}async function ge(){console.log("[Background] Starting frecency recalculation...");const e=Date.now();try{const t=(await chrome.storage.local.get("bookmarks")).bookmarks||[];if(t.length===0){console.log("[Background] No bookmarks to recalculate");return}let n=0;const r=t.map(a=>{var s;const u=((s=a.analytics)==null?void 0:s.importance)||50,l=Z(a);return u!==l&&n++,{...a,analytics:{...a.analytics,importance:l}}});await chrome.storage.local.set({bookmarks:r}),await chrome.storage.local.set({lastFrecencyRecalc:Date.now()});const i=Date.now()-e;console.log(`[Background] Frecency recalculation complete: ${n}/${t.length} bookmarks updated in ${i}ms`),chrome.runtime.sendMessage({type:"BOOKMARKS_UPDATED"}).catch(()=>{})}catch(o){console.error("[Background] Frecency recalculation failed:",o)}}chrome.alarms.onAlarm.addListener(async e=>{console.log("[Background] Alarm triggered:",e.name),e.name===P?ge():e.name==="import-batch"&&await ve()});de();async function $(){try{await chrome.sidePanel.setPanelBehavior({openPanelOnActionClick:!1}),console.log("[Background] Side panel behavior set: openPanelOnActionClick = false (popup menu mode)")}catch(e){console.error("[Background] Failed to set side panel behavior:",e)}}chrome.commands.onCommand.addListener(async e=>{if(console.log("[Background] Command received:",e),e==="open_popup")try{await chrome.action.openPopup(),console.log("[Background] Popup opened via command")}catch(o){console.error("[Background] Failed to open popup:",o),await chrome.windows.create({url:chrome.runtime.getURL("popup.html"),type:"popup",width:400,height:600})}});chrome.storage.onChanged.addListener((e,o)=>{if(o==="local"&&e.userSettings){const t=e.userSettings.newValue,n=e.userSettings.oldValue;(t==null?void 0:t.openMode)!==(n==null?void 0:n.openMode)&&(console.log("[Background] Open mode changed:",t==null?void 0:t.openMode),$())}});$();async function me(){try{if((await chrome.storage.local.get(["aiConfig","configInitialized"])).configInitialized){console.log("[Background] Config already initialized");return}const o={provider:"local"};await chrome.storage.local.set({aiConfig:o,configInitialized:!0}),console.log("[Background] Default config initialized (Local analysis mode)")}catch(e){console.error("[Background] Failed to initialize default config:",e)}}me();(async()=>{try{if(!(await chrome.storage.local.get(["onboardingSeen"])).onboardingSeen){console.log("[Background] Onboarding not seen, opening..."),await L();return}console.log("[Background] Extension ready, waiting for manual import")}catch(e){console.error("[Background] Startup check failed:",e)}})();chrome.runtime.onInstalled.addListener(async e=>{if(console.log("[Background] Extension installed:",e.reason),e.reason==="install"){L(),$(),console.log("[Background] Fresh install detected. Starting automatic backup to AnyMark...");try{const o=b();await o.initialize();const t=await o.importFromChromeNative();console.log("[Background] Automatic backup completed:",t)}catch(o){console.error("[Background] Automatic backup failed:",o)}}else e.reason==="update"&&Ae()});console.log("[Background] Using Chrome History API for visit tracking");chrome.commands.onCommand.addListener(async e=>{console.log("[Background] âŒ¨ï¸ Command triggered:",e);try{const o=await chrome.storage.local.get(["user","tokens"]);if(!!!(o.user&&o.tokens)){console.warn("[Background] User not authenticated, opening login page..."),await chrome.tabs.create({url:chrome.runtime.getURL("sidebar.html")});return}}catch(o){console.error("[Background] Failed to check authentication:",o);return}switch(e){case"quick_save":console.log("[Background] Executing quick_save..."),q();break;case"open-sidebar-tab":console.log("[Background] Opening sidebar in new tab..."),chrome.tabs.create({url:chrome.runtime.getURL("sidebar.html")}).catch(o=>{console.warn("[Background] Failed to open sidebar tab:",o)});break;default:console.warn("[Background] Unknown command:",e)}});chrome.runtime.onMessage.addListener((e,o,t)=>{switch(console.log("[Background] Message received:",e),console.log("[Background] Sender:",o),e.type){case"OPEN_SIDEBAR":case"TOGGLE_SIDEBAR":return he(o).then(()=>t({success:!0})).catch(r=>t({success:!1,error:r.message})),!0;case"OPEN_IN_TAB":return chrome.tabs.create({url:chrome.runtime.getURL("sidebar.html")}).then(()=>t({success:!0})).catch(r=>t({success:!1,error:r.message})),!0;case"SAVE_BOOKMARK":return U(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"ANALYZE_FOR_SAVE":return Me(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"GET_BOOKMARKS":return Se().then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"ANALYZE_PAGE":return K(e.url).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"REIMPORT_BOOKMARKS":return console.log("[Background] REIMPORT_BOOKMARKS received, starting import to AnyMark..."),(async()=>{let r=!1;const i="bookmarkImportLock";try{await chrome.storage.local.remove(["importCompleted","importTask"]);const u=(await chrome.storage.local.get(i))[i],l=Date.now();if(u!=null&&u.timestamp&&l-u.timestamp<5*60*1e3){t({success:!1,error:"Import already in progress"}),r=!0;return}await chrome.storage.local.set({[i]:{timestamp:l,source:"REIMPORT_BOOKMARKS"}});const s=b(),f=T();await s.initialize(),await f.initialize();const h=await s.importFromChromeNative(g=>{console.log(`[Background] Import progress: ${g.current} - ${g.currentItem}`)});console.log("[Background] Import to AnyMark completed:",h),t({success:!0,data:h}),r=!0;const d=await s.getBookmarkTree();if(console.log("[Background] AnyMark tree:",d?"found":"not found"),d){await x(d,f),console.log("[Background] AnyMark tree structure:");const g=(c,m="")=>{if(console.log(`${m}${c.url?"ðŸ“„":"ðŸ“"} ${c.title} (id: ${c.id})`),c.children)for(const k of c.children)g(k,m+"  ")};g(d);const p=O(d,s.getAnyMarkRootId()),y=C(d,s.getAnyMarkRootId());console.log("[Background] Legacy bookmarks:",p.length),console.log("[Background] Legacy folders:",y.map(c=>c.name)),await chrome.storage.local.set({bookmarks:p,folders:y}),console.log("[Background] Updated legacy storage with",p.length,"bookmarks and",y.length,"folders")}else console.warn("[Background] AnyMark tree is empty, initializing empty storage"),await chrome.storage.local.set({bookmarks:[],folders:[]});await chrome.storage.local.set({importCompleted:!0,importTime:Date.now()}),chrome.runtime.sendMessage({type:"BOOKMARKS_IMPORTED",count:h.importedBookmarks}).catch(()=>{})}catch(a){console.error("[Background] Import to AnyMark failed:",a),r||t({success:!1,error:a.message})}finally{try{await chrome.storage.local.remove(i)}catch(a){console.warn("[Background] Failed to release import lock:",a)}}})().catch(r=>{console.error("[Background] REIMPORT_BOOKMARKS IIFE error:",r);try{t({success:!1,error:r.message})}catch{}}),!0;case"REIMPORT_FROM_CHROME":return console.log("[Background] REIMPORT_FROM_CHROME received, clearing and reimporting..."),(async()=>{let r=!1;const i="bookmarkImportLock";try{const u=(await chrome.storage.local.get(i))[i],l=Date.now();if(u!=null&&u.timestamp&&l-u.timestamp<5*60*1e3){t({success:!1,error:"Import already in progress"}),r=!0;return}await chrome.storage.local.set({[i]:{timestamp:l,source:"REIMPORT_FROM_CHROME"}});const s=b(),f=T();await s.initialize(),await f.initialize();const h=await s.reimportFromChromeNative(g=>{console.log(`[Background] Reimport progress: ${g.current} - ${g.currentItem}`)});console.log("[Background] Reimport to AnyMark completed:",h),t({success:!0,data:h}),r=!0;const d=await s.getBookmarkTree();if(console.log("[Background] AnyMark tree after reimport:",d?"found":"not found"),d){await x(d,f),console.log("[Background] AnyMark tree structure after reimport:");const g=(c,m="")=>{if(console.log(`${m}${c.url?"ðŸ“„":"ðŸ“"} ${c.title} (id: ${c.id})`),c.children)for(const k of c.children)g(k,m+"  ")};g(d);const p=O(d,s.getAnyMarkRootId()),y=C(d,s.getAnyMarkRootId());console.log("[Background] Legacy bookmarks:",p.length),console.log("[Background] Legacy folders:",y.map(c=>c.name)),await chrome.storage.local.set({bookmarks:p,folders:y}),console.log("[Background] Updated legacy storage with",p.length,"bookmarks and",y.length,"folders")}else console.warn("[Background] AnyMark tree is empty after reimport"),await chrome.storage.local.set({bookmarks:[],folders:[]});await chrome.storage.local.set({importCompleted:!0,importTime:Date.now()}),chrome.runtime.sendMessage({type:"BOOKMARKS_IMPORTED",count:h.importedBookmarks}).catch(()=>{})}catch(a){console.error("[Background] Reimport from Chrome failed:",a),r||t({success:!1,error:a.message})}finally{try{await chrome.storage.local.remove(i)}catch(a){console.warn("[Background] Failed to release import lock:",a)}}})().catch(r=>{console.error("[Background] REIMPORT_FROM_CHROME IIFE error:",r);try{t({success:!1,error:r.message})}catch{}}),!0;case"ONBOARDING_COMPLETE":return chrome.storage.local.set({onboardingSeen:!0}).then(()=>{console.log("[Background] Onboarding complete, waiting for manual import"),t({success:!0})}).catch(r=>t({success:!1,error:r.message})),!0;case"START_BATCH_ANALYSIS":return Be(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"GET_ANALYSIS_STATUS":const n=I.getStatus();return t({success:!0,data:n}),!0;case"CANCEL_BATCH_ANALYSIS":return I.cancelAll(),t({success:!0}),!0;case"FETCH_URL_CONTENT":return N(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"FETCH_URL_VIA_PROXY":return fe(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"EXTRACT_FROM_TAB":return pe(e.data).then(r=>t({success:!0,data:r})).catch(r=>t({success:!1,error:r.message})),!0;case"QUICK_SAVE_CURRENT_PAGE":return q().then(()=>t({success:!0})).catch(r=>t({success:!1,error:r.message})),!0;case"OPEN_SETTINGS":return t({success:!0}),!0;default:t({success:!1,error:"Unknown message type"})}});async function he(e){var o;try{console.log("[Background] Opening side panel from sender..."),console.log("[Background] Sender:",e);let t;if((o=e.tab)!=null&&o.windowId)t=e.tab.windowId,console.log("[Background] Using sender tab window ID:",t);else{const[n]=await chrome.tabs.query({active:!0,lastFocusedWindow:!0});t=n==null?void 0:n.windowId,console.log("[Background] Using active window ID:",t)}if(!t)throw console.error("[Background] No window ID found"),new Error("No active window found");console.log("[Background] Opening side panel for window:",t),await chrome.sidePanel.open({windowId:t}),console.log("[Background] Side panel opened successfully")}catch(t){throw console.error("[Background] Failed to open side panel:",t),console.error("[Background] Error details:",{message:t.message,stack:t.stack,name:t.name}),t}}async function L(){console.log("[Background] Opening onboarding page..."),await chrome.tabs.create({url:chrome.runtime.getURL("onboarding.html"),active:!0})}async function q(){var e,o;try{const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t||!t.url){console.warn("[Background] No active tab found");return}console.log("[Background] Quick saving:",t.title),await U({url:t.url,title:t.title||"Untitled",folderPath:"/",importSource:"quick_save"}),console.log("[Background] Quick save successful"),(e=chrome.notifications)==null||e.create({type:"basic",iconUrl:"icon.svg",title:chrome.i18n.getMessage("notification_saveSuccessTitle")||"Bookmark Saved",message:chrome.i18n.getMessage("notification_saveSuccessMessage",[t.title||""]),priority:1}),t.id&&chrome.tabs.sendMessage(t.id,{type:"SHOW_TOAST",data:{message:chrome.i18n.getMessage("notification_toastSaved")||"Bookmark saved",type:"success",duration:3e3}}).catch(()=>{console.log("[Background] Tab not ready for toast, only showing notification")})}catch(t){console.error("[Background] Quick save failed:",t),(o=chrome.notifications)==null||o.create({type:"basic",iconUrl:"icon.svg",title:chrome.i18n.getMessage("notification_saveFailTitle")||"Save Failed",message:chrome.i18n.getMessage("notification_saveFailMessage")||"Failed to save bookmark, please try again",priority:2})}}async function N(e){console.log("[Background] Fetching URL content:",e.url);try{const o=await fetch(e.url,{headers:{Accept:"text/html","User-Agent":"Mozilla/5.0 (compatible; AnyMark/2.0)"}});if(!o.ok)throw new Error(`HTTP ${o.status}`);return{html:await o.text()}}catch(o){throw console.error("[Background] Failed to fetch URL content:",o),o}}const ke="https://v1.j-o-x.tech/api";async function fe(e){var o;console.log("[Background] Fetching URL via proxy:",e.url);try{const r=`${((o=(await chrome.storage.local.get(["userSettings"])).userSettings)==null?void 0:o.proxyEndpoint)||ke}/fetch`,i=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:e.url})});if(!i.ok)throw new Error(`Proxy request failed: ${i.status}`);const a=await i.json();if(!a.html)throw new Error("Proxy response missing HTML content");return console.log("[Background] Successfully fetched via proxy"),{html:a.html}}catch(t){return console.error("[Background] Failed to fetch via proxy:",t),console.warn("[Background] Falling back to direct fetch"),await N(e)}}async function pe(e){console.log("[Background] Extracting content from tab:",e.tabId,e.url);try{const{tabId:o,fullContent:t=!1}=e,n=await chrome.tabs.get(o);if(!n||!n.url)throw new Error("Tab not found or not accessible");if(n.url.startsWith("chrome://")||n.url.startsWith("edge://")||n.url.startsWith("about:"))throw new Error("Cannot extract content from special pages");if(t){const r=await chrome.scripting.executeScript({target:{tabId:o},func:we});if(r&&r[0]&&r[0].result)return r[0].result}else{const r=await chrome.scripting.executeScript({target:{tabId:o},func:ye});if(r&&r[0]&&r[0].result)return r[0].result}throw new Error("Failed to extract content from tab")}catch(o){throw console.error("[Background] Failed to extract from tab:",o),o}}function ye(){const e=()=>{const n=['meta[name="description"]','meta[property="og:description"]','meta[name="twitter:description"]'];for(const r of n){const i=document.querySelector(r),a=i==null?void 0:i.getAttribute("content");if(a&&a.length>20)return a}return""},o=()=>{const n=document.querySelector('meta[name="keywords"]');return(n==null?void 0:n.getAttribute("content"))||""},t=()=>{var i,a;const n=["article","main",'[role="main"]',".content","#content"];for(const u of n){const l=document.querySelector(u);if(l){const s=((i=l.textContent)==null?void 0:i.trim())||"";if(s.length>100)return s.substring(0,2e3).replace(/\s+/g," ")}}return(((a=document.body.textContent)==null?void 0:a.trim())||"").substring(0,2e3).replace(/\s+/g," ")};return{url:window.location.href,title:document.title,description:e(),keywords:o(),bodyText:t()}}function we(){var r,i;const e=()=>{const a=['meta[name="description"]','meta[property="og:description"]','meta[name="twitter:description"]'];for(const u of a){const l=document.querySelector(u),s=l==null?void 0:l.getAttribute("content");if(s&&s.length>20)return s}return""},o=()=>{const a=document.querySelector('meta[name="keywords"]');return(a==null?void 0:a.getAttribute("content"))||""},t=()=>{var l,s;const a=["article","main",'[role="main"]',".content","#content"];for(const f of a){const h=document.querySelector(f);if(h){const d=((l=h.textContent)==null?void 0:l.trim())||"";if(d.length>100)return d.substring(0,2e3).replace(/\s+/g," ")}}return(((s=document.body.textContent)==null?void 0:s.trim())||"").substring(0,2e3).replace(/\s+/g," ")},n={url:window.location.href,title:document.title,description:e(),keywords:o(),bodyText:t()};try{const a=document.querySelector("article")||document.querySelector("main");a&&(n.article={title:document.title,content:a.innerHTML,textContent:((r=a.textContent)==null?void 0:r.trim())||"",excerpt:e(),length:((i=a.textContent)==null?void 0:i.length)||0})}catch(a){console.warn("[PageExtractor] Article extraction failed:",a)}return n}async function Be(e){var o;console.log("[Background] Starting batch analysis for",e.bookmarks.length,"bookmarks");try{const t=await I.addTasks(e.bookmarks);return(o=chrome.notifications)==null||o.create({type:"basic",iconUrl:"icon.svg",title:"æ™ºèƒ½åˆ†æžå·²å¯åŠ¨",message:`æ­£åœ¨åŽå°åˆ†æž ${t.totalTasks} ä¸ªä¹¦ç­¾ï¼Œå³ä½¿å…³é—­ä¾§è¾¹æ ä¹Ÿä¼šç»§ç»­å¤„ç†`,priority:1}),t}catch(t){throw console.error("[Background] Failed to start batch analysis:",t),t}}async function x(e,o){if(e.url)try{await o.getMetadata(e.id)||await o.createDefaultMetadata(e.id,"browser")}catch(t){console.warn("[Background] Failed to create metadata for:",e.id,t)}if(e.children)for(const t of e.children)await x(t,o)}function O(e,o,t="/"){const n=[];if(e.url&&n.push({id:`bookmark-${e.id}`,chromeId:e.id,url:e.url,title:e.title||"Untitled",folderPath:t,folderId:t==="/"?"root":`folder-${t}`,createTime:e.dateAdded||Date.now(),updateTime:Date.now(),importSource:"browser",status:"active",analytics:{visitCount:0,lastVisit:null,importance:50,readTime:0}}),e.children)for(const r of e.children){let i=t;!r.url&&r.id!==o&&(i=t==="/"?`/${r.title}`:`${t}/${r.title}`);const a=O(r,o,i);n.push(...a)}return n}function C(e,o,t="/"){var r;const n=[];if(console.log("[extractFoldersFromTree] Processing node:",e.title,"id:",e.id,"isRoot:",e.id===o,"hasUrl:",!!e.url),!e.url&&e.id!==o){const i=t==="/"?`/${e.title}`:`${t}/${e.title}`;if(console.log("[extractFoldersFromTree] Adding folder:",e.title,"path:",i),n.push({id:`folder-${i}`,chromeId:e.id,name:e.title,path:i,parentPath:t,createTime:e.dateAdded||Date.now(),bookmarkCount:((r=e.children)==null?void 0:r.filter(a=>a.url).length)||0}),e.children){for(const a of e.children)if(!a.url){const u=C(a,o,i);n.push(...u)}}}else if(e.children){console.log("[extractFoldersFromTree] Processing root children, count:",e.children.length);for(const i of e.children)if(console.log("[extractFoldersFromTree] Root child:",i.title,"hasUrl:",!!i.url),!i.url){const a=C(i,o,t);n.push(...a)}}return n}async function Ae(){console.log("[Background] Extension updated"),await D()}async function Me(e){var o;console.log("[Background] Analyzing for save:",e);try{const{url:t,title:n}=e;let r={url:t,title:n||"Untitled",description:"",keywords:"",bodyText:""};try{const[g]=await chrome.tabs.query({active:!0,currentWindow:!0});if(g&&g.url===t&&g.id&&!t.startsWith("chrome://")&&!t.startsWith("edge://")&&!t.startsWith("about:")){const p=await chrome.scripting.executeScript({target:{tabId:g.id},func:()=>{var m;const y=()=>{const k=['meta[name="description"]','meta[property="og:description"]','meta[name="twitter:description"]'];for(const B of k){const w=document.querySelector(B),A=w==null?void 0:w.getAttribute("content");if(A&&A.length>20)return A}return""},c=()=>{var B;const k=["article","main",'[role="main"]',".content","#content"];for(const w of k){const A=document.querySelector(w);if(A){const S=((B=A.textContent)==null?void 0:B.trim())||"";if(S.length>100)return S.substring(0,500).replace(/\s+/g," ")}}return""};return{url:window.location.href,title:document.title,description:y(),keywords:((m=document.querySelector('meta[name="keywords"]'))==null?void 0:m.getAttribute("content"))||"",bodyText:c()}}});(o=p==null?void 0:p[0])!=null&&o.result&&(r=p[0].result)}}catch(g){console.warn("[Background] Failed to extract content, using basic info:",g)}let i,a=[],u,l,s,f=[],h="/";try{const p=(await chrome.storage.local.get("bookmarks")).bookmarks||[],y=Array.from(new Set(p.filter(k=>k.folderPath).map(k=>k.folderPath))),m=await(await _()).analyzeBookmark(r,{existingFolders:y});i=m.summary,a=m.tags,l=Math.round((m.confidence||.5)*100),s=m.difficulty,console.log("[Background] AI Analysis completed:",{aiTags:a,aiConfidence:l})}catch(g){console.warn("[Background] AI analysis failed:",g)}const d={url:t,title:r.title,favicon:`https://www.google.com/s2/favicons?domain=${new URL(t).hostname}&sz=64`,suggestedFolder:h,aiSummary:i,aiTags:a,aiCategory:u,aiConfidence:l,aiDifficulty:s,aiTechStack:f};try{await chrome.runtime.sendMessage({type:"ANALYZE_COMPLETE",data:d}),console.log("[Background] Sent ANALYZE_COMPLETE message to FloatingChat")}catch(g){console.warn("[Background] Failed to send message to FloatingChat:",g)}return d}catch(t){throw console.error("[Background] Failed to analyze for save:",t),t}}async function U(e){console.log("[Background] Saving bookmark (V2):",e);try{const{url:o,title:t,folderPath:n="/",aiTags:r=[],aiSummary:i,aiCategory:a,aiConfidence:u,aiDifficulty:l,aiTechStack:s=[]}=e;let f=i,h=r,d=u,g=l,p=s,y=t||"Untitled";if(!i&&!a)try{if(!f){const w=await K(o);f=w.summary,h=w.tags,d=Math.round((w.confidence||.5)*100),g=w.difficulty}}catch(w){console.warn("[Background] AI analysis failed during save:",w)}const c=b(),m=T();await c.initialize(),await m.initialize();let k=c.getAnyMarkRootId();if(n&&n!=="/"){const w=n.split("/").filter(Boolean).pop();if(w){const S=(await c.getChildren(k)).find(R=>R.title===w&&!R.url);S?k=S.id:k=await c.createFolder({title:w,parentId:k})}}const B=await c.createBookmark({title:y,url:o,parentId:k});return await m.setMetadata(B,{aiSummary:f,aiTags:h,aiConfidence:d,aiDifficulty:g,aiTechStack:p,aiCategory:a,userTags:[],starred:!1,importSource:"manual"}),console.log("[Background] Bookmark saved successfully (V2):",B),chrome.runtime.sendMessage({type:"BOOKMARK_ADDED",data:{id:B,title:y}}).catch(()=>{}),{id:B,title:y}}catch(o){throw console.error("[Background] Failed to save bookmark:",o),o}}async function Se(){console.log("[Background] Getting all bookmarks...");try{const{bookmarks:e=[]}=await chrome.storage.local.get("bookmarks");return e}catch(e){throw console.error("[Background] Failed to get bookmarks:",e),e}}async function K(e){console.log("[Background] Analyzing page:",e);try{const t=(await chrome.storage.local.get("bookmarks")).bookmarks||[],n=Array.from(new Set(t.filter(a=>a.folderPath).map(a=>a.folderPath)));return await(await _()).analyzeBookmark({url:e,title:e},{existingFolders:n})}catch(o){throw console.error("[Background] Failed to analyze page:",o),o}}class be{constructor(){M(this,"queue",[]);M(this,"isProcessing",!1);M(this,"maxRetries",2);M(this,"batchSize",5);M(this,"delayBetweenBatches",2e3);M(this,"isCancelled",!1)}async addTasks(o){console.log(`[AnalysisQueue] Adding ${o.length} tasks to queue`),this.isCancelled=!1;const t=o.map(n=>({bookmarkId:n.id,url:n.url,title:n.title,status:"pending",retryCount:0}));return this.queue.push(...t),await this.saveQueueState(),this.isProcessing||this.processQueue(),{totalTasks:this.queue.length,pendingTasks:this.queue.filter(n=>n.status==="pending").length}}cancelAll(){console.log("[AnalysisQueue] Cancelling all pending tasks"),this.isCancelled=!0,this.queue.forEach(o=>{o.status==="pending"&&(o.status="completed")}),this.saveQueueState().catch(o=>{console.error("[AnalysisQueue] Failed to save cancellation state:",o)})}async processQueue(){if(this.isProcessing){console.log("[AnalysisQueue] Already processing");return}this.isProcessing=!0,console.log("[AnalysisQueue] Starting queue processing");try{const o=await _();for(;!this.isCancelled;){const r=this.queue.filter(a=>a.status==="pending");if(r.length===0){console.log("[AnalysisQueue] No more pending tasks");break}const i=r.slice(0,this.batchSize);console.log(`[AnalysisQueue] Processing batch of ${i.length} tasks`);for(const a of i){a.status="processing",await this.saveQueueState();try{console.log(`[AnalysisQueue] Analyzing: ${a.title}`);let u={url:a.url,title:a.title,description:"",bodyText:""};try{const d=G(a.url),g=new Promise((y,c)=>setTimeout(()=>c(new Error("Content extraction timeout")),5e3)),p=await Promise.race([d,g]);p&&(u={url:a.url,title:p.title||a.title,description:p.excerpt||"",bodyText:p.textContent||""},console.log(`[AnalysisQueue] Extracted content for: ${a.title}`))}catch(d){console.warn(`[AnalysisQueue] Content extraction failed for ${a.title}, using basic info:`,d)}const l=await o.analyzeBookmark(u),f=(await chrome.storage.local.get("bookmarks")).bookmarks||[],h=f.find(d=>d.id===a.bookmarkId);h&&(h.aiSummary=l.summary,h.aiTags=l.tags,h.aiDifficulty=l.difficulty,h.aiConfidence=Math.round((l.confidence||.5)*100),h.updateTime=Date.now(),await chrome.storage.local.set({bookmarks:f}),console.log(`[AnalysisQueue] Updated bookmark: ${a.title}`)),a.status="completed",await this.saveQueueState(),this.notifyProgress()}catch(u){console.error(`[AnalysisQueue] Failed to analyze ${a.title}:`,u),a.retryCount++,a.retryCount>=this.maxRetries?(a.status="failed",a.error=u.message):a.status="pending",await this.saveQueueState()}await new Promise(u=>setTimeout(u,1e3))}r.length>this.batchSize&&(console.log(`[AnalysisQueue] Waiting ${this.delayBetweenBatches}ms before next batch`),await new Promise(a=>setTimeout(a,this.delayBetweenBatches)))}const t=this.queue.filter(r=>r.status==="completed").length,n=this.queue.filter(r=>r.status==="failed").length;console.log(`[AnalysisQueue] Queue processing completed: ${t} succeeded, ${n} failed`),chrome.runtime.sendMessage({type:"ANALYSIS_QUEUE_COMPLETE",data:{completed:t,failed:n,total:this.queue.length}}).catch(()=>{console.log("[AnalysisQueue] Failed to notify completion (sidebar might be closed)")}),this.queue=[],await this.saveQueueState()}finally{this.isProcessing=!1}}async saveQueueState(){try{await chrome.storage.local.set({analysisQueue:{queue:this.queue,isProcessing:this.isProcessing,timestamp:Date.now()}})}catch(o){console.error("[AnalysisQueue] Failed to save queue state:",o)}}async restoreQueueState(){try{const t=(await chrome.storage.local.get("analysisQueue")).analysisQueue;t&&t.queue&&t.queue.length>0&&(console.log(`[AnalysisQueue] Restoring ${t.queue.length} tasks from storage`),this.queue=t.queue,this.queue.forEach(n=>{n.status==="processing"&&(n.status="pending")}),this.isProcessing||this.processQueue())}catch(o){console.error("[AnalysisQueue] Failed to restore queue state:",o)}}notifyProgress(){const o=this.queue.length,t=this.queue.filter(i=>i.status==="completed").length,n=this.queue.filter(i=>i.status==="failed").length,r=this.queue.filter(i=>i.status==="pending").length;chrome.runtime.sendMessage({type:"ANALYSIS_QUEUE_PROGRESS",data:{total:o,completed:t,failed:n,pending:r,progress:Math.round(t/o*100)}}).catch(()=>{})}getStatus(){const o=this.queue.length,t=this.queue.filter(a=>a.status==="completed").length,n=this.queue.filter(a=>a.status==="failed").length,r=this.queue.filter(a=>a.status==="pending").length,i=this.queue.filter(a=>a.status==="processing").length;return{total:o,completed:t,failed:n,pending:r,processing:i,isProcessing:this.isProcessing,progress:o>0?Math.round(t/o*100):0}}}const I=new be;I.restoreQueueState();async function ve(){console.log("[Background] Processing import batch...");try{const o=(await chrome.storage.local.get("importTask")).importTask;if(!o||o.status!=="in_progress"){console.log("[Background] No active import task");return}const{bookmarks:t,currentIndex:n,importedBookmarks:r}=o;if(n>=t.length){console.log("[Background] All bookmarks imported, saving and cleaning up..."),await chrome.storage.local.set({bookmarks:r,importCompleted:!0,importTime:Date.now()}),await chrome.storage.local.remove("importTask"),await chrome.storage.local.remove("bookmarkImportLock"),console.log("[Background] Import lock released"),chrome.runtime.sendMessage({type:"BOOKMARKS_IMPORTED",count:r.length}).catch(f=>{console.log("[Background] Failed to notify sidebar:",f.message)}),console.log(`[Background] Successfully imported ${r.length} bookmarks`);return}const i=50,a=Math.min(n+i,t.length),u=t.slice(n,a);console.log(`[Background] Processing batch ${Math.floor(n/i)+1}, bookmarks ${n}-${a}/${t.length}`);const l=[];for(const s of u)try{const h={id:`bookmark-${crypto.randomUUID()}`,chromeId:s.id,url:s.url||"",title:s.title||"Untitled",favicon:s.url?`chrome://favicon/${s.url}`:void 0,folderPath:s.folderPath||"/",folderId:"imported",createTime:s.dateAdded||Date.now(),updateTime:Date.now(),importSource:"browser",userTitle:void 0,userTags:[],userNotes:void 0,starred:!1,pinned:!1,aiSummary:void 0,aiTags:[],aiCategory:void 0,aiSubcategory:void 0,aiConfidence:void 0,analytics:{visitCount:0,lastVisit:null,importance:50,readTime:0},relatedBookmarks:void 0,duplicateOf:void 0,status:"active",archiveTime:void 0};l.push(h)}catch(f){console.error("[Background] Failed to process bookmark:",f)}r.push(...l),o.currentIndex=a,o.importedBookmarks=r,await chrome.storage.local.set({importTask:o}),console.log(`[Background] Batch completed, total imported: ${r.length}`),a<t.length&&await chrome.alarms.create("import-batch",{delayInMinutes:.1})}catch(e){console.error("[Background] Failed to process import batch:",e);try{await chrome.storage.local.remove("bookmarkImportLock"),console.log("[Background] Import lock released after error in batch processing")}catch(o){console.error("[Background] Failed to release lock:",o)}}}
