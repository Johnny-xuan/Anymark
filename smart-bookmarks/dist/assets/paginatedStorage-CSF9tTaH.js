var b=Object.defineProperty;var P=(h,e,o)=>e in h?b(h,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):h[e]=o;var m=(h,e,o)=>P(h,typeof e!="symbol"?e+"":e,o);const w="SmartBookmarksDB";const c="bookmarks",u="index";class x{constructor(){m(this,"db",null);m(this,"index",null);m(this,"cache",new Map);m(this,"maxCachePages",5)}async initialize(){return new Promise((e,o)=>{const a=indexedDB.open(w,1);a.onerror=()=>{console.error("[PaginatedStorage] Failed to open database"),o(a.error)},a.onsuccess=()=>{this.db=a.result,console.log("[PaginatedStorage] Database opened"),this.loadIndex().then(e).catch(o)},a.onupgradeneeded=s=>{const t=s.target.result;if(!t.objectStoreNames.contains(c)){const r=t.createObjectStore(c,{keyPath:"id"});r.createIndex("pageNumber","pageNumber",{unique:!1}),r.createIndex("category","aiCategory",{unique:!1}),r.createIndex("folder","folderId",{unique:!1}),r.createIndex("starred","starred",{unique:!1})}t.objectStoreNames.contains(u)||t.createObjectStore(u,{keyPath:"id"}),console.log("[PaginatedStorage] Database upgraded")}})}async migrateFromChromeStorage(){try{const o=(await chrome.storage.local.get("bookmarks")).bookmarks||[];o.length>0&&(console.log(`[PaginatedStorage] Migrating ${o.length} bookmarks from Chrome Storage`),await this.saveAllBookmarks(o),console.log("[PaginatedStorage] Migration completed"))}catch(e){console.error("[PaginatedStorage] Migration failed:",e)}}async saveAllBookmarks(e){if(!this.db)throw new Error("Database not initialized");const o=Math.ceil(e.length/100),a=new Map,s=new Map;for(let t=0;t<o;t++){const r=t*100,d=Math.min(r+100,e.length),i=e.slice(r,d),l=this.db.transaction([c],"readwrite"),g=l.objectStore(c);for(const n of i){const f={...n,pageNumber:t};g.put(f),n.aiCategory&&(a.has(n.aiCategory)||a.set(n.aiCategory,[]),a.get(n.aiCategory).includes(t)||a.get(n.aiCategory).push(t)),n.folderId&&(s.has(n.folderId)||s.set(n.folderId,[]),s.get(n.folderId).includes(t)||s.get(n.folderId).push(t))}await new Promise((n,f)=>{l.oncomplete=()=>n(),l.onerror=()=>f(l.error)})}this.index={totalCount:e.length,pageSize:100,totalPages:o,categories:a,folders:s,lastUpdated:Date.now()},await this.saveIndex()}async loadPage(e){const o=this.cache.get(e);if(o&&Date.now()-o.loadedAt<6e4)return o.bookmarks;if(!this.db)throw new Error("Database not initialized");return new Promise((a,s)=>{const i=this.db.transaction([c],"readonly").objectStore(c).index("pageNumber").getAll(e);i.onsuccess=()=>{const l=i.result.map(g=>{const{pageNumber:n,...f}=g;return f});this.updateCache(e,l),a(l)},i.onerror=()=>s(i.error)})}async loadRange(e,o){const a=Math.floor(e/100),s=Math.floor(o/100),t=[];for(let g=a;g<=s;g++)t.push(this.loadPage(g));const d=(await Promise.all(t)).flat(),i=e%100,l=o-e+1;return d.slice(i,i+l)}async loadByCategory(e){if(!this.index||!this.index.categories.has(e))return[];const a=this.index.categories.get(e).map(t=>this.loadPage(t));return(await Promise.all(a)).flat().filter(t=>t.aiCategory===e)}async loadByFolder(e){if(!this.index||!this.index.folders.has(e))return[];const a=this.index.folders.get(e).map(t=>this.loadPage(t));return(await Promise.all(a)).flat().filter(t=>t.folderId===e)}async addBookmark(e){if(!this.db||!this.index)throw new Error("Database not initialized");const o=Math.floor(this.index.totalCount/100),a=this.db.transaction([c],"readwrite"),s=a.objectStore(c),t={...e,pageNumber:o};s.add(t),await new Promise((r,d)=>{a.oncomplete=()=>{this.index.totalCount++,e.aiCategory&&(this.index.categories.has(e.aiCategory)||this.index.categories.set(e.aiCategory,[]),this.index.categories.get(e.aiCategory).includes(o)||this.index.categories.get(e.aiCategory).push(o)),this.saveIndex(),this.invalidateCache(o),r()},a.onerror=()=>d(a.error)})}async updateBookmark(e,o){if(!this.db)throw new Error("Database not initialized");const s=this.db.transaction([c],"readwrite").objectStore(c),t=s.get(e);await new Promise((r,d)=>{t.onsuccess=()=>{const i=t.result;if(i){const l={...i,...o};s.put(l),this.invalidateCache(i.pageNumber)}r()},t.onerror=()=>d(t.error)})}async deleteBookmark(e){if(!this.db)throw new Error("Database not initialized");const a=this.db.transaction([c],"readwrite").objectStore(c),s=a.get(e);await new Promise((t,r)=>{s.onsuccess=()=>{const d=s.result;d&&(a.delete(e),this.index&&(this.index.totalCount--,this.invalidateCache(d.pageNumber))),t()},s.onerror=()=>r(s.error)})}getTotalCount(){var e;return((e=this.index)==null?void 0:e.totalCount)||0}getTotalPages(){var e;return((e=this.index)==null?void 0:e.totalPages)||0}updateCache(e,o){if(this.cache.set(e,{pageNumber:e,bookmarks:o,loadedAt:Date.now()}),this.cache.size>this.maxCachePages){let a=null,s=Date.now();for(const[t,r]of this.cache.entries())r.loadedAt<s&&(s=r.loadedAt,a=t);a!==null&&this.cache.delete(a)}}invalidateCache(e){this.cache.delete(e)}clearCache(){this.cache.clear()}async loadIndex(){if(this.db)return new Promise((e,o)=>{const t=this.db.transaction([u],"readonly").objectStore(u).get("main");t.onsuccess=()=>{t.result&&(this.index={...t.result,categories:new Map(Object.entries(t.result.categories||{})),folders:new Map(Object.entries(t.result.folders||{}))},console.log("[PaginatedStorage] Index loaded:",this.index)),e()},t.onerror=()=>o(t.error)})}async saveIndex(){if(!(!this.db||!this.index))return new Promise((e,o)=>{const a=this.db.transaction([u],"readwrite"),s=a.objectStore(u),t={id:"main",...this.index,categories:Object.fromEntries(this.index.categories),folders:Object.fromEntries(this.index.folders)};s.put(t),a.oncomplete=()=>e(),a.onerror=()=>o(a.error)})}}let p=null;async function y(){return p||(p=new x,await p.initialize()),p}export{x as PaginatedStorageManager,y as getPaginatedStorage};
